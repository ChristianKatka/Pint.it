<!DOCTYPE html>
<html lang='en'>

<head>

  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1, shrink-to-fit=no'>
  <meta name='description' content=''>
  <meta name='author' content=''>

  <title>Pint.it portfolio</title>

  <!-- Bootstrap core CSS -->
  <link href='vendor/bootstrap/css/bootstrap.min.css' rel='stylesheet'>
  <link href='css/modern-business.css' rel='stylesheet'>
  <link rel='stylesheet' href='./themes/prism.css'>

</head>

<body>

  <nav class='navbar navbar-dark bg-dark fixed-top test'>
    <a class='navbar-brand' href='index.html'>Portfolio - Pint.it</a>
  </nav>

  <div class='container'>

    <h1 class='text-center mt-3'>Pint.it <img src='./images/logo.png' width='50' height='50'></h1>
    <p class='text-center mb-4'>Oluiden ympärille keskittynyt sosiaalinen media.</p>

    <h2 class='text-center m-3 mb-4'>Alkusanat</h2>

    <p class='text-center'>
      Toimin pääkehittäjänä Pint.it-sovelluksen parissa. Tein tasaisesti frontendia sekä backendia ja huolehdin, että
      jokainen ohjelmiston osa on valmis
      julkaisuun kehityksen lopussa. Pidin huolen, että jokainen noudattaa yhteisiä <i>Coding guidelines</i>
      -määritteitä, jotta koodi olisi helposti luettavaa
      sekä kunnollista. Osallistuin myös jokaiseen tiimiämme koskevaan tekniseen haasteeseen, sekä otin vastuun, jos
      jokin meni pieleen.
    </p>

    <p class='text-center'>
      Suurin tekninen haaste oli NativeScriptin XML -kielen opettelu, johon kuluikin monta viikkoa projektin
      alkuvaiheessa. Vaikka käytimme jo vanhastaan tuttua
      Express -kirjastoa backendin rakentamiseen, päätimme ottaa Sequelize -frameworkin MySQL-tietokannan ohelle, joka
      samalla toi lisää haastetta projektiin.
    </p>


    <h2 class='text-center m-3 mb-4'>Tavoitteet</h2>
    
    <p class='text-center'>
      Kovalla työllä sekä ylimääräisien tuntien takia saimme toimivan sosiaalisen median aikaiseksi aikataulussa.
      Käyttäjä voi rekisteröityä/kirjautua sisään normaalisti tai sosiaalisen alustan avulla. Käyttäjä voi myös
      luoda
      uusia postauksia,
      joissa hän voi arvostella olutta mielensä mukaan. Hän pystyy kommentoimaan toisten postauksia sekä tykätä
      muiden
      postauksista ja
      kommenteista. Käyttäjällä on myös mahdollisuus muokata profiiliaan sekä seurata toisia käyttäjiä, joiden
      sisällöstä he tykkäävät.
    </p>
        
    <p class='text-center'>
      Aikataulun puutteen vuoksi emme kuitenkaan saaneet mielestäni tarpeeksi oluisiin liittyvää sisältöä, joka
      olisi
      erottanut meitä
      tarpeeksi muista oluisiin liittyvistä sovelluksista (käyttäjän oma olutlista, Google Maps -paikannin baareille
      jne.).
    </p>



    <h2 class='text-center mx-3 mt-5 mb-4'>Osaaminen</h2>

    <div class='row'>

      <div class='col-lg-6 mb-4 pb-5'>
        <h3 class='bg-dark text-white rounded p-1 text-center'>Frontend</h3>
        <div class='card h-100'>
          <img src='./images/nativescript-angular-logo.png' class='center img-fluid'>
          <h3 class='text-center p-2 '><u>NativeScript + Angular</u></h3>
          <div class='card-body'>
            <h4 class='mt-2'>Hankittu osaaminen</h4>
            <ul>
              <li>Extensible Markup Language (XML)</li>
              <li>UI/UX -tyylittely mobiili-applikaatioille</li>
              <li>Puhelimen ominaisuuksien käyttö (kamera, notifikaatiot jne.)</li>
              <li>Virheenkäsittely</li>
              <li>Elementtien manipulointi</li>
              <li>Kuvien tallentaminen sekä lähettäminen Base64String -muodossa</li>
              <li>Sosiaalinen kirjautuminen (Google & Facebook)</li>
            </ul>
            <h4 class='mt-2'>Syvennetty osaaminen</h4>
            <ul>
              <li>Komponentit</li>
              <li>Asynkroninen ohjelmointi</li>
              <li>Autentikaatio</li>
              <li>HTTP-kyselyt</li>
            </ul>
          </div>
        </div>
      </div>

      <div class='col-lg-6 mb-4 pb-5'>
        <h3 class='bg-dark text-white rounded p-1 text-center'>Backend</h3>
        <div class='card h-100'>
          <img src='./images/nodejs-express-logo.png' class='center img-fluid'>
          <h3 class='text-center p-2 '><u>Node.js + Express</u></h3>
          <div class='card-body'>
            <h4 class='mt-2'>Hankittu osaaminen</h4>
            <ul>
              <li>Sosiaalinen autentikaatio (Google & Facebook)</li>
              <li>ORM (Sequelize)</li>
              <li>Automaattisesti päivittyminen Herokuun</li>
              <li>Kuvien manipulointi sekä siirto Cloudinaryyn</li>
            </ul>
            <h4 class='mt-2'>Syvennetty osaaminen</h4>
            <ul>
              <li>Virheenkäsittely</li>
              <li>CRUD</li>
              <li>Autentikaatio</li>
              <li>Tokenin luonti sekä validointi</li>
            </ul>
          </div>
        </div>
      </div>

      <div class='col-lg-6 mb-4 pb-5'>
        <h3 class='bg-dark text-white rounded p-1 text-center'>Tietokanta</h3>
        <div class='card h-100'>
          <img src='./images/mysql-logo.png' class='center img-fluid'>
          <h3 class='text-center p-2 '><u>MySQL</u></h3>
          <div class='card-body'>
            <h4 class='mt-2'>Hankittu osaaminen</h4>
            <ul>
              <li>Siirto Amazon RDS -tietokantaan</li>
            </ul>
            <h4 class='mt-2'>Syvennetty osaaminen</h4>
            <ul>
              <li>Tietokantojen suunnittelu ryhmässä (ER- & tietokantamallit)</li>
              <li>Työskentely terminaalissa</li>
              <li>Monimutkaiset relaatiot</li>
              <li>Mock-data</li>
              <li>Optimointi</li>
            </ul>
          </div>
        </div>
      </div>

      <div class='col-lg-6 mb-4 pb-5'>
        <h3 class='bg-dark text-white rounded p-1 text-center'>GitHub</h3>
        <div class='card h-100'>
          <img src='./images/github-logo.png' class='center img-fluid'>
          <h3 class='text-center p-2 '><u>GitHub + ZenHub</u></h3>
          <div class='card-body'>
            <h4 class='mt-2'>Hankittu osaaminen</h4>
            <ul>
              <li>Taskien kirjoittelu</li>
              <li>Merge-konfliktien manuaalinen korjaus</li>
              <li>Branchien käyttöönotto</li>
              <li>Työskentely samassa repositoryssa tiimin kanssa</li>
            </ul>
            <h4 class='mt-2'>Syvennetty osaaminen</h4>
            <ul>
              <li>GitHub -työskentely terminaalissa</li>
              <li>Commit-viestien kirjoittelu</li>
            </ul>
          </div>
        </div>
      </div>

      <div class='col-lg-6 mb-4 pb-5'>
        <h3 class='bg-dark text-white rounded p-1 text-center'>Työkalut</h3>
        <div class='card h-100'>
          <img src='./images/tools-logo.png' class='center img-fluid h-50 w-50 m-2'>
          <div class='card-body'>
            <ul>
              <li>Terminaali</li>
              <li>VSCode</li>
              <li>NgRok</li>
              <li>Linux Mint</li>
              <li>GitHub + ZenHub</li>
              <li>NPM</li>
              <li>Postman</li>
              <li>Heroku, AWS & Cloudinary</li>
            </ul>
          </div>
        </div>
      </div>

      <div class='col-lg-6 mb-4 pb-5'>
        <h3 class='bg-dark text-white rounded p-1 text-center'>Scrum</h3>
        <div class='card h-100'>
          <div class='card-body'>
            <ul>
              <li>Päivittäiset scrum-meetingit</li>
              <li>Retrospektiivi</li>
              <li>Viikkopalaverit</li>
              <li>Spring planning day</li>
            </ul>
          </div>
        </div>
      </div>

    </div>

    <hr>

    <h2 class='text-center m-4 mb-5'>Tärkeimmät toiminnallisuudet</h2>

    <h4 class='text-center mb-4'><u>Postauksien selailu</u></h4>

    <div id="demo" class="carousel mb-5" data-ride="carousel" data-interval="false">
      <div class="carousel-inner bg-dark">

        <div class="carousel-item active">
          <div class='row'>
            <div class='col'>
             <pre><code class='language-xml'>
                        &lt;!-- FRONTPAGE.COMPONENT.HTML --&gt;

                        &lt;RadListView *ngIf='contents' [items]='contents' pullToRefresh='true'
                          (pullToRefreshInitiated)='getPosts(0, true, $event)' loadOnDemandMode='Auto'
                          (loadMoreDataRequested)=
                            'getPosts(contents.length, false, false, $event)' #contentList&gt;
                          &lt;ng-template let-item='item'&gt;
                            &lt;StackLayout&gt;
                              &lt;GridLayout columns='auto auto *' 
                                rows='70 * * * auto auto'&gt;
                                &lt;!-- POSTAUKSET --&gt;
                              &lt;/GridLayout&gt;
                            &lt;/StackLayout&gt;
                          &lt;/ng-template&gt;
                        &lt;/RadListView&gt;
              </code></pre>
            </div>
            <div class='col'>
              <img src='./example-images/demo1.png' class='img-fluid'>
            </div>
          </div>
          <div class='carousel-caption'>
            <b>1. </b>Jokainen haettu posti tulee <kbd>RadListView</kbd> -elementin sisälle. Kyseinen elementti
            mahdollistaa scrollattavan
            listan lisäksi
            muita toiminnallisuuksia kuten: <kbd>pullToRefreshInitiated</kbd> ja <kbd>loadMoreDataRequested</kbd>.
          </div>
        </div>

        <div class="carousel-item">
          <pre><code class='language-typescript'>
            // FRONTPAGE.COMPONENT.TS

            public getPosts(amount: number, reset?: boolean,
              pullUpEvent?: ListViewEventData, loadMoreEvent?: LoadOnDemandListViewEventData): void {

                this._postService.getPosts(this.postOrder, this.postFilter, amount).subscribe(posts => {
                  // If method was called with 'Pull up to refresh' -method
                  if (pullUpEvent) pullUpEvent.object.notifyPullToRefreshFinished();
                  // If method was while scrolling down to fetch more posts
                  if (loadMoreEvent) loadMoreEvent.object.notifyLoadOnDemandFinished();
                
                  // If new posts will overwrite older posts
                  if (reset) this.contents = [];
                  // Tell activity indicator that first posts has been fetched
                  this.isBusy = false;
                
                  if (posts.length > 0) {
                    // Push every post received to an array of objects
                    posts.forEach(post => this.contents.push({ post: post }));
                   // Takes ID's from every post fetched
                    const postIds = posts.map(post => post.id);
                
                    this.getLikesForPosts(postIds);
                    this.getPostUserLikes(postIds);
                    this.getCommentAmounts(postIds);
                    this.getComments(postIds);
                  }
                }, err => {
                  console.error(err);
                  // If method was called with 'Pull up to refresh' -method
                  if (pullUpEvent) pullUpEvent.object.notifyPullToRefreshFinished();
                  // If method was while scrolling down to fetch more posts
                  if (loadMoreEvent) loadMoreEvent.object.notifyLoadOnDemandFinished();
                  this.isBusy = false;
                  this._convertService.convertPrompt('Postauksia ei voitu hakea', null, null, 5);
              });
            }
          </code></pre>
          <div class='carousel-caption'>
            <b>2. </b>Frontpage-komponentista löytyvä funktio, mikä tekee postauksen haun servicen kautta. Parametrien
            sekä muuttujien
            ansiosta tiedämme tarkalleen, mistä kohdasta postauksia haluamme hakea, miten ne filtteröidään sekä
            tyhjennetäänkö vanhat postaukset.
          </div>
        </div>

        <div class="carousel-item">
          <pre><code class='language-typescript'>
              // dataclasses/content.ts

              import { Post } from './post';
              import { Comment } from './comment';

              export class Content {

                post: Post;
                comments?: Comment[];
                commentAmount?: number;
                likes?: number;
              }
          </code></pre>
          <div class='carousel-caption'>
            <b>3. </b>Koska jokaiseen postaukseen halutaan lisätä myös tykkäyksien määrä, kommenttien määrä sekä
            maksimissaan 2 viimeisintä
            kommentia, teemme uuden taulukon
            <kbd>public content: Content[]</kbd>, joka sisältää postauksen sekä muut ylimääräiset tiedot.
          </div>
        </div>

        <div class="carousel-item">
          <pre><code class='language-typescript'>
            // POST.SERVICE.TS

            public getPosts(category1: string, category2: string, position: number): Observable&lt;Post[]&gt; {
              const headers = ({ headers: this.createHeaders() });
              // Determines in which order posts will be fetched
              const order = category1 === 'Uusimmat' ? 'createdAt' : 'value'
              // Search all user posts, or search posts only by followed
              const posturl = category2 === 'Kaikki' ? 'all' : 'followed';
              // Get user id from Nativescript's localstorage
              const userId = localStorage.getNumber('id');
              // HTTP Query
              return this._http.get<Post[]>(
                `${this.url}posts${posturl}/${order}/${position}/${userId}`, headers
                ).pipe(map(res => {
                  res.forEach(p => {
                    p.date = this._convertService.convertDate(p.createdAt);
                    p.stars = this._convertService.convertRating(p.rating);
                  });
                  return res;
                })
              );
            }
        </code></pre>
          <div class='carousel-caption'>
            <b>4. </b>Service tekee puolestamme GET-kyselyn backendiin riippuen siitä haluaako käyttäjä kaikkien
            postaukset vai pelkästään
            niiden, joita hän seuraa. Kun 5 postausta
            palautuu, käytämme toista serviceä, <kbd>ConvertService</kbd>, joka muuttaa päivämäärän sekä
            numero-arvosanan.
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-javascript'>
              // POST.CONTROLLER.JS

              findPostsByFollowed: (req, res) => {
                Models.Post.findAll({
                  offset: Number(req.params.position),
                  subQuery: false,
                  limit: 5,
                  order: [[req.params.order, 'DESC']],
                  where: { '$User->followed.user_id$': req.params.userId },
                  include: [{
                    attributes: ['img'],
                    model: Models.User,
                    required: true,
                    include: [{
                    attributes: [],
                      model: Models.Relation,
                      as: 'followed',
                      required: true,
                    }]
                  }]
                }).then(posts => {
                  if (posts.length < 1) {
                    return res.status(404).send({ 
                      'msg': 'Postauksia ei löydetty käyttäjälle: ' + req.params.userId
                    });
                  }
                  return res.send(posts);
                }).catch(err => {
                  console.error(err);
                  res.status(500).send(err);
                });
              },
          </code></pre>
          <div class='carousel-caption'>
            <b>5. </b>Postauksia käyttäjille haetaan funktioista <kbd>findPostsByFollowed()</kbd> tai
            <kbd>findPostsByAll()</kbd>. Ylläolevassa funktiossa tehdään
            kaksi <kbd>INNER JOIN</kbd> kutsua, jotta voimme samalla tutkia <kbd>Relation</kbd> -taulun yhteyttä, ja
            katsoa keitä käyttäjiä seurataan.
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-xml'>
            &lt;!-- PROFILE-IMG, USERNAME &amp; DATE --&gt;
            &lt;GridLayout row='0' rows='auto auto' columns='70 *' colspan='3' class='m-t-5'&gt;
              &lt;Image row='0' col='0' rowspan='2' class='profile-img' [nsRouterLink]=&quot;['/profile/', item.post.username]&quot;
                src=' {{ item.post.User.img ? url + item.post.User.img : url + &quot;default-picture&quot; }}.png'
                stretch='aspectFill'&gt;
              &lt;/Image&gt;
              &lt;Label row='0' col='1' [text]='item.post.username' class='h2'
                [nsRouterLink]=&quot;['/profile/', item.post.username]&quot;&gt;&lt;/Label&gt;
              &lt;Label row='1' col='1' class='time-stamp' [text]='item.post.date'&gt;&lt;/Label&gt;
            &lt;/GridLayout&gt;
            
            &lt;!-- POST PICTURE --&gt;
            
            &lt;GridLayout row='1' colspan=&quot;3&quot; rows=&quot;*&quot; columns=&quot;*&quot;&gt;
              &lt;Image (doubleTap)='animateLike(thumb); toggleLikePost(item.post.id, item.post.username)'
               *ngIf='item.post.img' src='{{ url + item.post.img }}.png' class='m-y-10'&gt;&lt;/Image&gt;
              &lt;Label #thumb row='1' colSpan=&quot;1&quot; class='fas doubletap-thumb' fontSize='40'
               text='&amp;#xf79f;'&gt;&lt;/Label&gt;
            &lt;/GridLayout&gt;
            
            &lt;!-- BEER NAME, TYPE &amp; GRADE --&gt;
            &lt;GridLayout row='2' rows='* auto auto' columns='100 auto' class='beer-info'&gt;
              &lt;Label *ngIf='item.post.drink_name' row='0' col='0' colspan='2' [text]='item.post.drink_name'
               class='beer-name'&gt;&lt;/Label&gt;
              &lt;Label *ngIf='item.post.drink_type' row='1' col='0' colspan='2' text='Tyyppi:' fontWeight='bold'&gt;&lt;/Label&gt;
              &lt;Label *ngIf='item.post.drink_type' row='1' col='2' [text]='item.post.drink_type'&gt;&lt;/Label&gt;
              &lt;Label *ngIf='item.post.rating &gt; 0' row='2' col='0' colspan='2' text='Arvosana:'
               fontWeight='bold'&gt;&lt;/Label&gt;
              &lt;Label *ngIf='item.post.rating &gt; 0' row='2' col='2' [text]='item.post.stars'
                class='fas'&gt;&lt;/Label&gt;
            &lt;/GridLayout&gt;
            
            &lt;!-- DESCRIPTION --&gt;
            &lt;StackLayout row='3' col='0' colspan='3' (tap)='toggleDesc(shortDesc, longDesc)' class='desc-area'&gt;
              &lt;Label #shortDesc textWrap='true'&gt;
                &lt;FormattedString&gt;
                  &lt;Span
                    text='{{ item.post.text.length &gt; 150 ? (item.post.text | slice:0:150) : (item.post.text)&nbsp;}}'&gt;&lt;/Span&gt;
                  &lt;Span *ngIf='item.post.text.length &gt; 150' text='.. N&auml;yt&auml; lis&auml;&auml;'
                    class='expand-desc'&gt;&lt;/Span&gt;
                &lt;/FormattedString&gt;
              &lt;/Label&gt;
              &lt;Label #longDesc textWrap='true' visibility='collapse'&gt;
                &lt;FormattedString&gt;
                  &lt;Span text='{{ item.post.text }}'&gt;&lt;/Span&gt;
                  &lt;Span *ngIf='item.post.text.length &gt; 150' text=' N&auml;yt&auml; v&auml;hemm&auml;n'
                    class='expand-desc'&gt;&lt;/Span&gt;
                &lt;/FormattedString&gt;
              &lt;/Label&gt;
            &lt;/StackLayout&gt;
            
            &lt;!-- LIKES AND COMMENTS -AMOUNT --&gt;
            &lt;StackLayout row='4' col='0' columns='auto auto' class='like-comment-area'&gt;
              &lt;Label #loginButton [backgroundColor]='item.post.liked ? &quot;#855909&quot; : &quot;#a4a4a5&quot;'
                text='&amp;#xf164; {{ item.likes ? convertNumber(item.likes) : 0&nbsp;}} tykk&auml;yst&auml;'
                (tap)='toggleLikePost(item.post.id, item.post.username, loginButton)' class='fas
                like-amount-box-active'&gt;&lt;/Label&gt;
              &lt;Label (tap)='showAllComments(item.post.id, item.post.username)'
                text='&amp;#xf075; {{ item.commentAmount ? convertNumber(item.commentAmount) : 0 }} kommenttia'
                class='fas comment-amount-box'&gt;&lt;/Label&gt;
            &lt;/StackLayout&gt;
            
            &lt;!-- COMMENT-AREA --&gt;
            &lt;StackLayout row='5' col='0' colspan='3' class='comment-area' *ngIf='item.comments'&gt;
              &lt;StackLayout *ngFor='let c of item.comments'&gt;
                &lt;GridLayout columns='auto auto *' rows='35 * auto'&gt;
                  &lt;Image row='0' col='0'
                    src='{{ c.comment_owner.img ? url + c.comment_owner.img : url + &quot;default-picture&quot; }}.png'
                    [nsRouterLink]=&quot;['/profile/', c.username]&quot;&gt;&lt;/Image&gt;
                  &lt;GridLayout row='0' col='1' rows='* *' columns='* *' rowspan='2' colspan='3' class='comment-text'
                      (tap)='showAllComments(item.post.id)'&gt;
                    &lt;Label row='0' col='0' [text]='c.username' class='comment-name'
                      [nsRouterLink]=&quot;['/profile/', c.username]&quot;&gt;&lt;/Label&gt;
                    &lt;Label row='1' col='0' colspan='3' [text]='c.text' textWrap='true'&gt;&lt;/Label&gt;
                  &lt;/GridLayout&gt;
                  &lt;Label #thumb (tap)='toggleLikeComment(c.id, c.username, item.post.id, thumb)' row='2' col='1'
                    [color]='c.liked ? &quot;#b67f64&quot; : &quot;#595959&quot;' text='&amp;#xf164; {{ c.likes ? c.likes : 0 }}'
                    class='fas'&gt;
                  &lt;/Label&gt;
                  &lt;Label row='2' col='2' text='&amp;#xf017; {{ c.date }}' class='far'&gt;&lt;/Label&gt;
                &lt;/GridLayout&gt;
              &lt;/StackLayout&gt;
            &lt;/StackLayout&gt;
          </code></pre>
          <div class='carousel-caption'>
            <b>6. </b> Yhden postauksen XML-muotoilu. <br>
            Yksi postaus sisältää suuren määrän XML-koodia. Postauksen sisälle on kaikki tarvittava data mitä postauksesta pitää
            nähdä mm. 2 viimeisintä kommenttia, postaajan tiedot sekä itse postin tiedot.
          </div>
        </div>

      </div>
      <a class="carousel-control-prev" href="#demo" data-slide="prev">
        <span class="carousel-control-prev-icon"></span>
      </a>
      <a class="carousel-control-next" href="#demo" data-slide="next">
        <span class="carousel-control-next-icon"></span>
      </a>
    </div>





    <h5 class='text-center my-4'>Kuinka liitämme muut tiedot postaukseen?</h5>

    <div id="demo2" class="carousel  mb-5" data-ride="carousel" data-interval="false">
      <div class="carousel-inner bg-dark">

        <div class="carousel-item active">
          <pre><code class='language-typescript'>
            // FRONTPAGE.COMPONENT.TS

              public getLikesForPosts(postIds: number[]): void {
                this._likeService.getPostsLikes(postIds).subscribe(likes => {
                  for (const content of this.contents) {
                    if (content.likes) continue;
                    for (const like of likes) {
                      if (content.post.id === like.post_id) {
                        content.likes = like.count;
                        break;
                      }
                    }
                  }
                });
              }
          </code></pre>
          <div class='carousel-caption'>
            <b>1. </b>Kun käyttäjälle on haettu postaukset, kutsumme muita alempana olevia funktiota, jotka
            tekevät omat HTTP-kyselyt backendiin. Implementoimme haun niin,
            ettei jokaiselle postaukselle, tykkäysmäärälle jne. ole omaa pientä HTTP-kyselyä eikä myöskään yhtä isoa ja
            raskasta hakua, joka hakisi kaiken kerrallaan.
          </div>
        </div>

        <div class="carousel-item">
          <pre><code class='language-typescript'>
            // LIKE.SERVICE.TS
            public getPostsLikes(postIds: Number[]): Observable<any> {
              const headers = ({ headers: this.createHeaders() });
              return this._http.get(
                `${this.url}postslikes/${postIds.join('-')}`, headers
              );
            }
          </code></pre>
          <div class='carousel-caption'>
            <b>2. </b>5 postauksen ID:t lähetetään eteenpäin serviceen, ja nämä ID:t viedään backendiin. Numero-taulu muutetaan
            HTTP-kyselyn ajaksi yhdeksi stringiksi <kbd>[1, 4, 6] => '1-4-6'</kbd>.
          </div>
        </div>


        <div class='carousel-item'>
          <pre><code class='language-javascript'>
            // LIKE.CONTROLLER.JS

            getPostsLikes: (req, res) => {
              Models.PostLikes.count({
                attributes: ['post_id'],
                where: { post_id: {
                  [Op.in]: req.params.ids.split('-').map(Number)
                }},
                group: 'post_id'
              })
                .then(likeAmounts => {
                  if (likeAmounts.length < 1) { 
                    return res.status(404).send({ 
                      'msg' : 'Could not find any likes with: ' + req.params.ids
                    }); 
                  } 
                  return res.send(likeAmounts); }) 
                .catch(err=> {
                  console.error(err);
                  return res.status(500).send(err);
              });
            },
          </code></pre>
          <div class='carousel-caption'>
            <b>3. </b>Backendin funktiossa ID-string muutetaan takaisin numero-taulukoksi ja niitä verrataan <kbd>PostLikes</kbd>-tauluun.
            Jos taulusta löytyy ID:n avulla yhteyksiä, palautetaan numeromäärä sekä ID takaisin. Esim. <kbd>[{ post_id: 25, count: 38 }, { post_id: 5, count: 1 }]</kbd>.
          </div>
        </div>
      </div>
      <a class="carousel-control-prev" href="#demo2" data-slide="prev">
        <span class="carousel-control-prev-icon"></span>
      </a>
      <a class="carousel-control-next" href="#demo2" data-slide="next">
        <span class="carousel-control-next-icon"></span>
      </a>
    </div>


    <h4 class='text-center mt-5 mb-2'><u>Postauksen luominen</u></h4>


    <div id="demo3" class="carousel  mb-5" data-ride="carousel" data-interval="false">
      <div class="carousel-inner bg-dark long">
          
        <div class='carousel-item active'>
          <img src='./example-images/demo3-1.png' class='center img-fluid'>
          <div class='carousel-caption'>
            <b>1. </b> Uudesta postauksesta oltiin tehty omat mock-upit, mutta käyttäjätestauksen jälkeen huomasimme, että moni piti uuden postauksen luomista
            hyvinkin epäselvänä. Päätimme lopulta erottaa kuvan sekä tekstin oluesta tabeilla.
          </div>
        </div>

        <div class='carousel-item'>
          <img src='./example-images/demo3-2.png' class='center img-fluid'>
          <div class='carousel-caption'>
            <b>2. </b> Postauksen julkaisussa vain teksti on pakollinen - kaikki muut tiedot ovat vapaaehtoisia. Kaikki täytettävät tiedot menevät yhden muuttujan,
            <kbd>const post: Post</kbd>, sisälle (pl. kuva).
          </div>
        </div>

        <div class='carousel-item'>
          <img src='./example-images/demo3-3.png' class='center img-fluid'>
          <div class='carousel-caption'>
            <b>3. </b> Kuvan voi valita joko painamalla kameran kuvaa tai avaamalla klemmarin alhaalta. Kun kuva on valittu, haetaan sen osoite käyttäjän omasta 
            puhelimesta, jotta kuva voidaan näyttää ennen postauksen lähetystä.
          </div>
        </div>

        <div class='carousel-item'>
          <div class='row'>
            <div class='col'>
              <pre><code class='language-typescript'>
                  // IMAGE.SERVICE.TS

                  public takePicture(callback): void {
                    camera.requestPermissions().then(() => {
                      const options = {
                        height: 500,
                        keepAspectRatio: true,
                        saveToGallery: true
                      };
                      camera.takePicture(options)
                        .then(imageAsset => {
                          const source = new ImageSource();
                          const picture = new Image();
                          picture.src = imageAsset.android;
                          source.fromAsset(imageAsset).then(source => {
                            callback({ 
                              picture: picture, 
                              base64picture: source.toBase64String(
                                'jpg', 30) }, null);
                          });
                        });
                      }).catch(err => {
                        this._convertService.convertPrompt(
                          'Kuvaa ei voitu valita', null, null, 5
                        );
                        callback(null, err)
                    });
                  }
              </code></pre>
            </div>
            <div class='col'>
              <pre><code class='language-typescript'>
                // IMAGE.SERVICE.TS

                public getPicture(callback): void {

                  const context = imagepicker.create({
                    mode: 'single'
                  });
                  context.authorize().then(() => {
                    return context.present();
                  })
                  .then(imageAsset => {
                    const source = new ImageSource();
                    const picture = new Image();
                    picture.src = imageAsset[0].android;
                    source.fromAsset(imageAsset[0])
                      .then(source => {
                        callback({ picture: picture, 
                          base64picture: source.toBase64String(
                            'jpg', 30) }, null);
                    });
                  })
                  .catch(err => {
                    this._convertService.convertPrompt(
                      'Kuvaa ei voitu valita', null, null, 5
                    );
                    callback(null, err)
                  });
                }
              </code></pre>
            </div>
          </div>
          <div class='carousel-caption'>
            <b>4. Kuinka kuvan tallentaminen ja lähettäminen onnistuu?</b> Service <kbd>image.service.ts</kbd> huolehtii kuvista. Kun käyttäjä ottaa kuvan kamerallaan tai valitsee yhden galleriasta,
            muutetaan kuva Base64String -muotoon. Kutsuvaan komponenttiin tuodaan takaisin valitun kuvan osoite sekä sama kuva tekstimuodossa.
          </div>
        </div>


        <div class='carousel-item'>
          <pre><code class='language-typescript'>
              // CREATEPOST.COMPONENT.TS

              public sendPost(): void {
                if (this.post.text) {
                  this.isBusy = true;
                  this._postService.createPost(this.post, this.base64picture, this.username)
                    .subscribe(() => {
                      this.isBusy = false;
                      this._routerExtensions.navigate(
                        ['/frontpage'], { animated: true, transition: {
                          name: 'slide', duration: 200, curve: 'easeInOut'
                      }});
                    }, err => {
                      console.error(err);
                      this.isBusy = false;
                      this._convertService.convertPrompt('Postausta ei voitu lähettää', null, null, 5);
                    });
                } else {
                  this._convertService.convertPrompt('Postauksen teksti ei voi olla tyhjä', null, null, 2);
                }
              }
          </code></pre>
          <div class='carousel-caption'>
            <b>5. </b> Kun käyttäjä painaa 'Julkaise' -nappia, tarkastetaan onko käyttäjä antanut pakollisen osion (teksti). Jos teksti on lisätty,
            viedään tieto serviceen joka edeslähettää sen backendiin.
          </div>
        </div>


        <div class='carousel-item'>
          <pre><code class='language-typescript'>
            // POST.SERVICE.TS

            public createPost(post: Post, image: string, username: string): Observable&lt;any&gt; {
              // Remove extra line breaks from text
              post.text = post.text.replace(/\n\s*\n/g, '\n\n');
              const headers = ({ headers: this.createHeaders() });
              // If user chose an image within the post
              const postContent = image ? { post: post, image: image } : { post: post };
              return this._http.post(`${this.url}createpost/${username}`, postContent, headers);
            }
          </code></pre>
          <div class='carousel-caption'>
            <b>6. </b> Tiedot postauksesta siirtyvät serviceen, joka tekee HTTP-POST kutsun eteenpäin backendille. Servicessä myös tutkitaan, tekeekö käyttäjä
            postauksen kuvan kanssa vai ilman (tuotu kuva on tekstimuodossa <kbd>Base64String</kbd>).
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-javascript'>
              // POST.CONTROLLER.JS

              createPost: (req, res) => {
                Models.Post.create({
                  username: req.params.username,
                  text: req.body.post.text,
                  drink_name: req.body.post.drink_name,
                  drink_type: req.body.post.drink_type,
                  rating: req.body.post.rating,
                  // If image comes with the post, generate a name and place it to database, otherwise leave it empty
                  img: req.body.image ? crypto.pseudoRandomBytes(8).toString('hex') : ''
                })
                  .then(post => {
                    if (req.body.image) {
                      // Convert image from base64string format to a normal image
                      filepath = base64Img.imgSync(`data:image/jpg;base64,
                        ${req.body.image}`, '', post.img);
                      // Pick the image and push it to Cloudinary (image-hosting service)
                      cloudinary.v2.uploader.upload(filepath,
                        { public_id: post.img }, (error, result) => {
                          if (error) {
                            console.error(error);
                            return res.status(500).send(error);
                          }
                          console.log(result);
                      });
                    }
                    return res.send(post);
                  })
                  .catch(err => {
                    console.error(err);
                    return res.status(500).send({
                      message: 'Error retrieving ' + err
                    });
                  });
              },
          </code></pre>
          <div class='carousel-caption'>
            <b>7. </b> <kbd>createPost()</kbd> funktio hoitaa postauksen tallentamisen. Jos HTTP-kutsussa tuli kuva mukana, luodaan postauksen <kbd>img</kbd>
            -attribuutille nimi. Kun postaus on onnistuneesti tallennettu, käännämme Base64String -kuvan takaisin tavalliseksi kuvaksi kirjaston avulla ja tallennamme sen väliaikaisesti
            samaan hakemistoon. Tämän jälkeen puskemme uuden kuvan Cloudinary -palveluun ja annamme kuvalle nimeksi saman nimen kuin mitä uudelle postille annettiin.
          </div>
        </div>

        <div class='carousel-item'>
          <div class='row'>
            <div class='col-8 ml-3'>
              <pre><code class='language-xml'>
                &lt;!-- FRONTPAGE.COMPONENT.HTML --&gt;
                &lt;!-- http://res.cloudinary.com/ht3ndzrqd/image/upload/v1556714333/--&gt;
                &lt;!-- Postauksen KUVA-osio --&gt;

                &lt;GridLayout row='1' 
                  colspan=&quot;3&quot; 
                  rows=&quot;*&quot; 
                  columns=&quot;*&quot;&gt;
                  &lt;Image (doubleTap)='animateLike(thumb); 
                    toggleLikePost(item.post.id, item.post.username)'
                    *ngIf='item.post.img' src='{{ url + item.post.img }}.png' 
                    class='m-y-10'&gt;
                  &lt;/Image&gt;
                  &lt;Label #thumb row='1' colSpan=&quot;1&quot; 
                    class='fas doubletap-thumb' fontSize='40'
                    text='&amp;#xf79f;'&gt; 
                  &lt;/Label&gt;
                &lt;/GridLayout&gt;
              </code></pre>
            </div>
            <div class='col-3 mb-3'>
              <img src='./example-images/demo3-4.png' class='img-fluid'>
            </div>
          </div>
          <div class='carousel-caption'>
              <b>8. </b> Kun uusi postaus on tallennettu, käyttäjä navigoidaan takaisin etusivulle, jossa hän voi nähdä uusimman postauksensa. Uusin kuva haetaan Cloudinaryn sivuilta, yksilöiden kuvan
              postauksen <kbd>img</kbd> -attribuutin mukaan.
          </div>
        </div>


      </div>
        <a class="carousel-control-prev" href="#demo3" data-slide="prev">
          <span class="carousel-control-prev-icon"></span>
        </a>
        <a class="carousel-control-next" href="#demo3" data-slide="next">
          <span class="carousel-control-next-icon"></span>
        </a>
    </div>


    <h4 class='text-center mb-2 mt-5'><u>Kommentit</u></h4>

    <div id="demo10" class="carousel  mb-5" data-ride="carousel" data-interval="false">
      <div class="carousel-inner bg-dark">
        
        <div class='carousel-item active'>
          <div class='row'>
            <div class='col'>
              <pre><code class='language-typescript'>
                  // FRONTPAGE.COMPONENT.TS

                  public showAllComments(
                    postId: number, username: string): void {
                    const options = {
                      context: { postId, username },
                      fullscreen: true,
                      viewContainerRef: this.vcRef
                    };
                    this.modal.showModal(ModalCommentComponent, options)
                    .then(username => {
                      if (username) {
                        setTimeout(() => this.router.navigate([
                        '/profile', username]), 100);
                      } else {
                        this.getComments([postId], true);
                        this.getCommentAmounts([postId], true);
                      }
                    });
                  }
              </code></pre>
            </div>
            <div class='col'>
              <img src='./example-images/demo10-1.png' class='img-fluid center'>
            </div>
          </div>
          <div class='carousel-caption'>
            <b>1. </b> Käyttäjä näkee 2 viimeisintä kommenttia joka postauksen alla (jos postaukseen ollaan kommentoitu). Painamalla jompaakumpaa kommenttia tai painamalla
            kommentti-nappia, käyttäjä pääsee kommenttimodaaliin.
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-xml'>
            // COMMENT-MODAL.COMPONENT.HTML

            &lt;StackLayout #modal&gt;
              &lt;GridLayout rows='* auto'&gt;
                &lt;StackLayout row='0'&gt;
                  &lt;!-- CATEGORING COMMENTS --&gt;
                  &lt;StackLayout class='categorize-header'&gt;
                    &lt;GridLayout columns='* *' rows='auto'&gt;
                      &lt;Label (tap)='closeModal()' col='0'&gt;
                        &lt;FormattedString&gt;
                          &lt;Span text='&amp;#xf053;' class='fas'&gt;&lt;/Span&gt;
                          &lt;Span text=' Palaa takaisin'&gt;&lt;/Span&gt;
                        &lt;/FormattedString&gt;
                      &lt;/Label&gt;
                      &lt;Label horizontalAlignment='right' col='1' (tap)='changeCategory()'&gt;
                        &lt;FormattedString&gt;
                          &lt;Span text='&amp;#xf0dd; ' class='fas'&gt;&lt;/Span&gt;
                          &lt;Span [text]='order'&gt;&lt;/Span&gt;
                        &lt;/FormattedString&gt;
                      &lt;/Label&gt;
                    &lt;/GridLayout&gt;
                  &lt;/StackLayout&gt;
                  &lt;!-- NO COMMENTS --&gt;
                  &lt;StackLayout *ngIf='comments &amp;&amp; comments.length &lt; 1' class='no-comments-msg'&gt;
                    &lt;Label text='Ei kommentteja - ole ensimm&auml;inen!'&gt;&lt;/Label&gt;
                  &lt;/StackLayout&gt;

                  &lt;!-- ALL COMMENTS --&gt;
                  &lt;RadListView [items]='comments' pullToRefresh='true' 
                    (pullToRefreshInitiated)='getComments(0, true, $event)'
                    loadOnDemandMode='Auto' (loadMoreDataRequested)='getComments(comments.length, false, false, $event)'&gt;
                    &lt;ng-template let-item='item'&gt;
                      &lt;StackLayout&gt;
                        &lt;GridLayout columns='35 auto *' rows='35 * auto' class='comment'&gt;
                          &lt;Image class='user-img' row='0' col='0' (tap)='showUserProfile(item.username)'
                            src='{{ item.img ? url + item.img : url + &quot;default-picture&quot; }}.png'&gt;
                          &lt;/Image&gt;
                          &lt;GridLayout row='0' col='1' rows='* *' rowspan='2' colspan='3' class='comment-content'&gt;
                            &lt;Label row='0' [text]='item.username' class='comment-username'
                              (tap)='closeModal(item.username)'&gt;&lt;/Label&gt;
                            &lt;Label row='1' colspan='3' [text]='item.text' textWrap='true'&gt;&lt;/Label&gt;
                          &lt;/GridLayout&gt;
                          &lt;Label #thumb [color]='item.liked ? &quot;#b67f64&quot; : &quot;#595959&quot;' row='2' col='1'
                            text='&amp;#xf164; {{ item.likes ? item.likes : 0 }}' class='fas comment-lower-area'
                            (tap)='toggleLike(item.id, item.username, thumb)'&gt;&lt;/Label&gt;
                          &lt;Label row='2' col='2' text='&amp;#xf017; {{ item.date }}'
                            class='far comment-lower-area'&gt;&lt;/Label&gt;
                        &lt;/GridLayout&gt;
                      &lt;/StackLayout&gt;
                    &lt;/ng-template&gt;
                  &lt;/RadListView&gt;
                &lt;/StackLayout&gt;

              &lt;/GridLayout&gt;
            &lt;/StackLayout&gt;
          </code></pre>
          <div class='carousel-caption'>
            <b>2. </b> Kommentit tulevat <kbd>RadListView</kbd> -elementin sisään. Tämä mahdollistaa toiminnot kuten, <i>"Pull up to refresh"</i> ja <i>"Asynchronous & continuous loading"</i>.
          </div>
        </div>

        <div class='carousel-item'>
          <div class='row'>
            <div class='col-8'>
              <pre><code class='language-typescript'>
                  // MODAL-COMMENTS.COMPONENT.TS

                  public getComments(amount: number, reset?: boolean,
                    pullUpEvent?: ListViewEventData, 
                    loadMoreEvent?: LoadOnDemandListViewEventData): void {
                    if (reset) this.comments = [];
                    this._commentService.getComments(this.postId, this.order, amount)
                      .subscribe(comments => {
                        // If method was called with 'Pull up to refresh' -method
                        if (pullUpEvent) pullUpEvent.object.notifyPullToRefreshFinished();
                        // If method was while scrolling down to fetch more posts
                        if (loadMoreEvent) loadMoreEvent.object.notifyLoadOnDemandFinished();
                        // Push every comment to an array of objects
                        this.comments.push(...comments);
                        // Comments search-queries won't always place image to 
                        // same value. This will ensure the comments are always placed 
                        // in right value 
                        this.comments.forEach(comment => {
                          const img = comment.comment_owner && 
                            comment.comment_owner.img ? comment.comment_owner.img : null; 
                          comment.img = comment.img ? comment.img : img;
                        });
                        if (comments.length > 0) this.getCommentLikes(
                          comments.map(c => c.id));
                      }, err => {
                        this._convertService.convertPrompt('Kommentteja ei voitu hakea!');
                      });
                  }
              </code></pre>
            </div>
            <div class='col-4'>
              <img src='./example-images/demo10-2.png' class='img-fluid center'>
            </div>
          </div>
          <div class='carousel-caption'>
            <b>3. </b> Kommenttien haku toimii <b>täysin</b> samalla lailla kuin postauksien haku. Funktio siis mahdollistaa kommenttien asynkronisen, jatkuvan haun backendista.
            Kun kommentit on haettu, haetaan jokaiselle myös tykkäysmäärät (käyttäen samanlaista funktiota kuin postauksen tykkäyksiä hakiessa).
          </div>
        </div>


        <div class='carousel-item'>
          <pre><code class='language-typescript'>
                // MODAL-COMMENT.COMPONENT.TS
              public getCommentUserLikes(commentIds: number[]): void {
                this._likeService.getUserCommentLikes(commentIds).subscribe(userLikes => {
                  if (userLikes.length > 0) {
                    userLikes.forEach(userLike => {
                      this.comments.forEach(comment => {
                        if (comment.id === userLike.comment_id) {
                          comment.liked = true;
                        };
                      });
                    });
                  };
                });
              }

          // LIKE.SERVICE.TS
              public getUserCommentLikes(commentIds: number[]): Observable<CommentLike[]> {
                const headers = ({ headers: this.createHeaders() });
                const userId = localStorage.getNumber('id');
                return this._http.get<CommentLike[]>(
                  `${this.url}usercommentlikes/${userId}/${commentIds.join('-')}`, headers
                );
              }
          </code></pre>
          <div class='carousel-caption'>
            <b>4. Kuinka tarkistetaan onko käyttäjä tykännyt tietystä kommentista?</b> Kun setti kommentteja on haettu, niitten ID:t viedään funktioon, mikä lähettää ne servicen avulla backendiin.
            (Postauksista tykkääminen toimii täysin samalla lailla kuin kommentista tykkääminen).
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-javascript'>
              // LIKE.CONTROLLER.JS

              getUserCommentLikes: (req, res) => {
                Models.CommentLikes.count({
                  attributes: ['comment_id'],
                  where: {
                    comment_id: {
                      [Op.in]: req.params.comment_ids.split('-').map(Number)
                    },
                    user_id: req.params.user_id
                  },
                  group: 'comment_id'
                })
                  .then(userLikes => {
                    return res.send(userLikes);
                  })
                  .catch(err => {
                    console.error(err);
                    return res.status(500).send(err);
                  });
              },
          </code></pre>
          <div class='carousel-caption'>
            <b>5. </b> Backendissa kommenttien ID:t loopataan CommentLikes -taulun läpi, ja jos käyttäjän ID sekä kommentin ID löytyvät samalta riviltä, palautetaan se rivi takaisin
            frontendiin.
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-xml'>
            // COMMENT-MODAL.COMPONENT.HTML

            &lt;Label #thumb 
              <b>[color]='item.liked ? &quot;#b67f64&quot; : &quot;#595959&quot;'</b>
              row='2' col='1' text='&amp;#xf164; {{ item.likes ? item.likes : 0 }}' 
              class='fas comment-lower-area'
              (tap)='toggleLike(item.id, item.username, thumb)'&gt;
            &lt;/Label&gt;
          </code></pre>
          <div class='carousel-caption'>
            <b>6. </b> Serviceä kutsunut funktio saa taulukon, esim. <kbd>[{'comment_id': 2, liked: true}, {'comment_id': 255, liked:true}]</kbd> takaisin, joka loopataan kaikkien kommenttien läpi.
            Jos ID:t kohtaavat, annamme sille kommentti-oliolle arvon <kbd>liked: true</kbd>. Templaatissa väri vaihetaan tämän arvon mukaan.
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-typescript'>
              // MODAL-COMMENT.COMPONENT.TS

              public toggleLike(id: number, username: string, thumb: Label): void {
                // Gives thumb an animation whenever user presses it
                thumb.animate({
                  scale: { x: 2, y: 2 }, duration: 80
                });
                setTimeout(() => {
                  thumb.animate({
                    scale: { x: 1, y: 1 }, duration: 80
                  });
                }, 50);
                // Does the request to backend via service
                this._likeService.toggleUserCommentLike(id)
                  .subscribe(value => {
                    this.comments.forEach(comment => {
                      if (comment.id === id) {
                        // Visual color change whether user likes comment or not
                        comment.liked = value.liked ? true : false;
                        // Increment or decrement the likes -value
                        if (value.liked) {
                          if (!comment.likes) comment.likes = 0;
                          comment.likes++;
                          this.createNotification(username, 1, id);
                        } else {
                          comment.likes--;
                          this.deleteNotification(1, username, id);            
                        } 
                      }
                    });
                });
              }
          </code></pre>
          <div class='carousel-caption'>
            <b>7. Kuinka vaihdamme käyttäjän antaman tykkäyksen?</b> Kun käyttäjää klikkaa peukkua, tehdään servicen välityksellä HTTP-PUT kysely, jonne viedään käyttäjän sekä kommentin ID:t.
            Riippuen siitä, poistettiinko vai lisättiinkö tykkäys, vaihdetaan kommentin <kbd>liked</kbd> -arvoa sekä tykkäysmäärää.
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-javascript'>
              // LIKE.CONTROLLER.JS

              toggleUserCommentLike: (req, res) => {
                Models.CommentLikes.findOne({
                  where: {
                    comment_id: req.body.commentId,
                    user_id: req.body.userId
                  }
                })
                  .then(userLike => {
                    // If user has liked specific comment
                    if (userLike) {
                      Models.CommentLikes.destroy({
                        where: {
                          comment_id: req.body.commentId,
                          user_id: req.body.userId
                        }
                      }).then(() => res.send({ liked: false }));
                    }
                    // If user hasn't liked specific comment
                    else {
                      Models.CommentLikes.create({
                        comment_id: req.body.commentId,
                        user_id: req.body.userId
                      }).then(() => res.send({ liked: true }));
                    }
                  })
                  .catch(err => {
                    console.error(err);
                    return res.status(500).send(err);
                  });
              }
          </code></pre>
          <div class='carousel-caption'>
            <b>8. </b> Backendissa katsomme ekana löytyykö riviä, jossa olisi samat ID:t, ja sen mukaan joko poistamme rivin tai lisäämme sen ja lähetämme asianmukaisen palautteen takaisin frontendiin
            <kbd>{ liked: true / false }</kbd>.
          </div>
        </div>

      </div>
      <a class="carousel-control-prev" href="#demo10" data-slide="prev">
        <span class="carousel-control-prev-icon"></span>
      </a>
      <a class="carousel-control-next" href="#demo10" data-slide="next">
        <span class="carousel-control-next-icon"></span>
      </a>
    </div>
    


    <h4 class='text-center mb-2 mt-5'><u>Sisäänkirjautuminen ja rekisteröityminen</u></h4>

    <div id="demo4" class="carousel  mb-5" data-ride="carousel" data-interval="false">
      <div class="carousel-inner bg-dark">
        
        <div class='carousel-item active'>
          <img src='./example-images/demo4-1.png' class='img-fluid center'>
          <div class='carousel-caption'>
            <b>1. </b> Kun käyttäjä saapuu ensimmäistä kertaa applikaatioon, avautuu hänellä login-komponentti. Tästä näkymästä käyttäjä pystyy kirjautumaan sisään tai
            rekisteröitymään - tavalliseen tapaan tai sosiaalisesti.
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-typescript'>
            // MODAL-REGISTER.COMPONENT.TS

            public register(): void {
              if (this.socialRegistration || 
              (this.registerInfo.password && !this.registerInfo.password.match(this.passwordMatch))) {
                this._authService.register(this.registerInfo)
                .subscribe(res => {
                  this._params.closeCallback(res);
                }, err => {
                  this._convertService.convertPrompt('Rekisteröityminen epäonnistui');
                  console.error(err);
                })
              } else {
                this._convertService.convertPrompt('Salasana ei sisältää skandinaavisia aakkosia (Å, Ä & Ö)');
                this.registerInfo.password = '';
                this.registerInfo.rePassword = '';
              }
            }
          </code></pre>
          <img src='./example-images/demo4-2.png' class='img-fluid center m-5'>
          <div class='carousel-caption'>
            <b>2. Rekisteröityminen </b>. Rekisteröitymis -modaali avautuu kun käyttäjä haluaa rekisteröityä applikaatioon, tai on tekemässä ensimmäistä sosiaalista kirjautumista.
            Käyttäjätunnus tarkistetaan ennen kuin käyttäjä voi rekisteröityä. Sosiaalisessa kirjautumisessa salasanaa ei pyydetä.
          </div>
        </div>
        
        <div class='carousel-item'>
          <pre><code class='language-javascript'>
            // AUTH.CONTROLLER.JS

            register: (req, res) => {
              // If password is given, hash it
              if (req.body.password) {
                req.body.password = bcrypt.hashSync(req.body.password, 8);
              }
              Models.User.create({
                username: req.body.username,
                password: req.body.password, 
                social_id: req.body.socialId
              }, { exclude: { attributes: 'password'} })
              .then(user => {
                if (!user) {
                  return res.status(400).send({ error: 'Rekisteröinti epäonnistui' });
                }  
                return res.send({ user: user, token: createToken(user) });
              }).catch(err => {
                console.error(err);
                return res.status(500).send(err);
              }); 
            },
          </code></pre>
          <div class='carousel-caption'>
            <b>3. Rekisteröityminen </b> Käyttäjän tiedot tuodaan backendiin POST-kyselynä. Jos käyttäjä rekisteröityy sosiaalisesti, tallennetaan salasanan
              sijaan <kbd>social_id</kbd>. Käyttäjälle palautetaan hänen tietonsa + token, joka on 3kk voimassa.
            </b>
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-typescript'>
              // LOGIN.COMPONENT.TS

              public login(): void {
                if (this.username.match(this.usernameMatch)) { 
                  if (!this.password.match(this.passwordMatch)) {
                    this.logging = true;
                    this._authService.login(this.username, this.password).subscribe(
                      res => {
                        this.logging = false;
                        localStorage.clear();
                        this.navigateFrontpage(res);
                      },
                      err => {
                        console.error(err);
                        this.logging = false;
                        this._convertService.convertPrompt(
                          'Väärä käyttäjätunnus / salasana', 'Kirjautuminen epäonnistui');
                        this.username = '';
                        this.password = '';
                      }
                    );
                  } else {
                    this._convertService.convertPrompt(
                      'Salasana ei saa sisältää (Ä, Ö tai Å)', 'Kirjautuminen epäonnistui');
                    this.password = '';
                  }
                } else {
                    this._convertService.convertPrompt(
                      'Käyttäjätunnus hyväksyy (A-Z) & (0-9)', 'Kirjautuminen epäonnistui', null, 1);
                    this.username = '';
                  } 
              }
          </code></pre>
          <div class='carousel-caption'>
            <b>4. Kirjautuminen </b>. Käyttäjän tunnus ja salasana tarkistetaan ennenkuin ne viedään backendiin. Jos tiedot ovat
            sallittuja, viedään ne servicen kautta HTTP-POST kyselyllä backendiin.
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-javascript'>
              // AUTH.CONTROLLER.JS

              login: (req, res) => {
                Models.User.findOne({
                  where: { username: req.body.username },
                  exclude: { attributes: 'password'}
                }).then(user => {
                  // If no user were found
                  if (!user) {
                    return res.status(404).send({ error: 'Käyttäjää ei löytynyt' })
                  }
                  // If given password and database's password aren't same
                  if (!bcrypt.compareSync(req.body.password, user.password ? user.password : '')) {
                    return res.status(403).send({ error: 'Väärä salasana' })
                  }
                  return res.send({ token: createToken(user), user: user })
                }).catch(err => {
                  console.error(err);
                  return res.status(500).send({ error: err })
                });
              },
          </code></pre>
          <div class='carousel-caption'>
            <b>5. Kirjautuminen</b>. Backendissa käyttäjän antamaa salasanaa verrataan tietokannassa olevaan salasanaan
            <kbd>BCrypt</kbd> -kirjaston avulla. Jos salasana on oikea, palautetaan käyttäjälle hänen tietonsa sekä token (3kk voimassa).
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-typescript'>
              // LOGIN.COMPONENT.TS

              public navigateFrontpage(data?: LoggedUser, skip?: boolean): void {
                // If user has already logged in before
                if (!skip) {
                  
                  // If user data is being passed through parameter
                  if (data) {
                    localStorage.setNumber('id', data.user.id);
                    localStorage.setString('username', data.user.username);
                    localStorage.setString('token', data.token);
                    if (data.user.img) localStorage.setString('img', data.user.img);
                  }
                  // If there's no data (ONLY GOOGLE'S SOCIAL LOGIN WITHOUT SOCIAL-REGISTRATION)
                  else {
                    const creds = JSON.parse(localStorage.getString('userCreds'));
                    localStorage.remove('userCreds');
                    localStorage.setNumber('id', creds.id);
                    localStorage.setString('username', creds.username);
                    if (creds.img) localStorage.setString('img', creds.img);
                  } 
                }
                // Tell navbar that user has logged in and it can be shown
                this._authService.sendLoginInfo(true);

                // Navigate to frontpage
                setTimeout(() => {
                  this.routerExtension.navigate(['/frontpage'], {
                    animated: true,
                    transition: { name: 'slide', duration: 200, curve: 'easeInOut' },
                    clearHistory: true
                  });
                }, 50);
              }
          </code></pre>
          <div class='carousel-caption'>
            <b>6. </b> Jos kirjautuminen / rekisteröityminen onnistuu, ohjataan käyttäjä vielä yhden funktion läpi, mikä asettaa <kbd>LocalStorage</kbd> -varastoon
            tarvittavat tiedot käyttäjästä.
          </div>
        </div>

      </div>
        <a class="carousel-control-prev" href="#demo4" data-slide="prev">
          <span class="carousel-control-prev-icon"></span>
        </a>
        <a class="carousel-control-next" href="#demo4" data-slide="next">
          <span class="carousel-control-next-icon"></span>
        </a>
    </div>


    <h4 class='text-center mb-2 mt-5'><u>Sosiaalinen kirjautuminen</u></h4>

    <div id="demo5" class="carousel  mb-5" data-ride="carousel" data-interval="false">
      <div class="carousel-inner bg-dark">
        
        <div class='carousel-item active'>
          <pre><code class='language-typescript'>
              // LOGIN.COMPONENT.TS

              public socialLogin(platform: string): void {
                tnsOauthLogin(platform)
                  .then((result: ITnsOAuthTokenResult) => {
                    this._authService.socialLogin(result, platform).subscribe(
                      res => {
                        if (!res.redirect) {
                          if (platform === 'facebook') {
                            this.register(res.socialId);
                          }
                        } else {
                          if (platform === 'facebook') {
                            this.navigateFrontpage(res);
                          }
                        }
                      },
                      err => {
                        console.error(err);
                        this._convertService.convertPrompt(
                          'Sosiaalinen kirjautuminen epäonnistui');
                      }
                    );
                  }).catch(err => {
                    console.error(err);
                    this._convertService.convertPrompt(
                      'Sosiaalinen kirjautuminen epäonnistui');
                  });
              }
          </code></pre>
          <div class='carousel-caption'>
          <b>1. </b> Kun käyttäjä painaa Facebook / Google -näppäintä, suoritetaan funktio, joka avaa hänelle alustan mukaisen sosiaalisen 
          kirjautumisen. Jos alustan kirjautuminen onnistuu, viemme saadut <kbd>Token</kbd> -tiedot serviceen.
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-typescript'>
              // AUTH.SERVICE.TS

              public socialLogin(result: ITnsOAuthTokenResult, platform: string): Observable&lt;LoggedUser&gt; {
                // Depending on the platform, change the route of the social-login
                const route = platform === 'google' ? 'googlelogin' : 'fblogin';
                return this._http.post&lt;LoggedUser&gt;(this.url + route, result, headers)
                  .pipe(map(res =&gt; {
                    if (platform === 'google') {
                      if (!res.redirect) {
                        // Google -&gt; Social login
                        localStorage.setString('platform', platform);
                        localStorage.setString('socialId', res.socialId);
                      } else {
                        // Google -&gt; Social registration
                        localStorage.setString('platform', platform);
                        localStorage.setString('userCreds', JSON.stringify(res.user));
                        localStorage.setString('token', res.token);
                      }
                    }
                    return res;
                  }
                ));
              }
          </code></pre>
          <div class='carousel-caption'>
            <b>2. </b>Servicessä lähetämme HTTP-POST kyselyn sen mukaan kumpaan sosiaaliseen alustaan kirjautuminen tehtiin.
          </div>
        </div>

        <div class='carousel-item'>
          <div class='row'>
            <div class='col-6'>
              <pre><code class='language-javascript'>
                  // AUTH.CONTROLLER.JS

                  googleLogin: (req, res, next) => {
                    validateGoogleLogin(req.body.idToken)
                      .then(id => {
                      console.log('Google\'s USER id: ' + id);
                      socialID = id;
                      next();
                    }).catch(err => {
                      console.error(err);
                      return res.status(500).send(err);
                    });
                  },
              </code></pre>
            </div>
            <div class='col-6'>
              <pre><code class='language-javascript'>
                  // AUTH.CONTROLLER.JS

                  fbLogin: (req, res, next) => {
                    validateFbLogin(req.body.accessToken, 
                      (creds, err) => {
                      if (err) {
                        console.error(err);
                        return res.status(403).send(err);
                      }
                      socialID = creds.id;
                      next();
                    })
                  },
              </code></pre>
            </div>
          </div>
          <div class='carousel-caption'>
            <b>3. </b> HTTP-pyynnöllä tullut token viedään URLin mukaiseen funktioon. Kummatkin funktiot kutsuvat toista funktiota, joka validoi tokenin ja palauttaa käyttäjän uniikin ID:n.
            Facebook validoi tokenin <kbd>GRAPH APILLA</kbd> ja Google <kbd>Google Auth Library</kbd> -kirjastolla. Saatu ID tallennetaan globaalin muuttujaan väliaikaisesti.
          </div>
        </div>

        <div class='carousel-item'>
          <pre><code class='language-javascript'>
              // AUTH.CONTROLLER.JS

              searchSocialUser: (req, res) => {
                Models.User.findOne({
                  attributes: {
                    include:  ['id', 'username', 'img'], 
                    exclude: ['password']
                  },
                  where: { 'social_id': socialID },
                }).then(user => {
                  // If no user were found
                  if (!user) {
                    return res.send({ redirect: false, socialId: socialID });
                  }
                  return res.send({ redirect: true, user: user, token: createToken(user) });
                }).catch(err => {
                  console.error(err);
                  return res.status(500).send(err);
                })
              },
          </code></pre>
          <div class='carousel-caption'>
            <b>4. </b> Kun käyttäjän ID on haettu, etsitään kyseistä käyttäjää tietokannasta <kbd>social_id</kbd> -attribuutilla. Jos sosiaalinen käyttäjä löytyy, palautetaan käyttäjän
            tiedot + token. Muussa tapauksessa vain <kbd>social_id</kbd> palautetaan ja käyttäjä viedään rekisteröitymis-modaaliin.
          </div>
        </div>

      </div>
      <a class="carousel-control-prev" href="#demo5" data-slide="prev">
        <span class="carousel-control-prev-icon"></span>
      </a>
      <a class="carousel-control-next" href="#demo5" data-slide="next">
        <span class="carousel-control-next-icon"></span>
      </a>
    </div>


    <h2 class='text-center m-3 mt-5 mb-4'>Mitä olisin parantanut</h2>

    <p class='text-center'>Jo projektin alussa oli puhetta, että jos tietokannan suunnittelu saadaan valmiiksi yhdessä päivässä,
      se ei ole valmis. Tämä sama "sääntö" koski meitäkin. Tietokantaa suunniteltiin yksi päivä - ja sitä korjattiin ajan kanssa 
      myöhemmin kun huomasimme normalisointi-virheitä sekä puuttuvia kohtia. 
    </p>

    <ul class='mx-5 mb-4'>
      <li>
        <kbd>UserRelation</kbd> -taulu todettiin turhaksi (2 käyttäjää pystyttiin identifikoimaan kahdella attribuutilla), joten pystyimme minimoimaan sen yhteen tauluun
      </li>
      <li>
        <kbd>Comment</kbd> & <kbd>Post</kbd> -taulujen <kbd>likes</kbd> -attribuutit siirretään moni-moneen suhteen tauluun, jotta käyttäjä, joka on tykännyt jommastakummasta 
        voidaan identifioida
      </li>
      <li>
        Monet taulut (esim. <kbd>Notification</kbd>, <kbd>Post</kbd> & <kbd>Comment</kbd>) sisälsivät jo olemassa olevaa tietoa uudestaan, joten teimme näistä relaatiot
      </li>
    </ul>

    <div class='row'>
      <div class='col-6'>
        <p class='text-center'><u>Vanha tietokantamalli</u></p>
        <img src='./example-images/db-old.png' class='img-fluid'>
      </div>
      <div class='col-6'>
        <p class='text-center'><u>Uusi tietokantamalli</u></p>
        <img src='./example-images/db-new.png' class='img-fluid'>
      </div>
    </div>


    <p class='text-center mt-5'>Projektissamme esiintyi myös jonkun verran toistettavuutta koodin kanssa. Eritoten <kbd>Profile</kbd> ja <kbd>Frontpage</kbd>
      -komponentit sisälsivät paljon samojen funktioiden ja templaattien toistamista. Ajan kanssa nämä ongelmat oltaisiin voitu poistaa esim. Angularin 
      <kbd>@Input / @Output</kbd> -metodeilla.
    </p>

    <p class='text-center mt-3'>Välillä myöskään muuttujien yhteneväisyys ei ollut samaa - jotkut muuttujat saatettiin kirjoittaa camelCasella (userLikes) ja osa
      alaviivalla (user_likes).
    </p>

    
    <h2 class='text-center m-3 mt-5 mb-4'>Reflektointi</h2>

    <p class='text-center'>
      Tämä oli ensimmäinen ohjelmistoprojektini, jossa oli mukana myös muita ihmisiä. Pienissä kopissa töiden tekeminen 5 päivää viikossa ryhmän kanssa opetti minulle, kuinka ohjelmistoja
      voidaan luoda ryhmässä suunnittelujen ja koodausten kera.
    </p>

    <p class='text-center'>
      Pärjäsin Ticorporaten aikana mielestäni varsin hyvin - työntunteja minulle kertyi lopussa 450h~ sekä committien määrä nousi 225:een. Motivaationi ei luisunut 
      kuukausien aikana paljon yhtään, vaan pysyi yhtä korkealla opintojakson loppuun asti.
    </p>

    <p class='text-center'>
      Ryhmäprojekti erosi omista projekteistani siten, ettei koodia voitu niin vaan puskea omaan tahtiin vaan kaikki piti olla hyvin dokumentoitu ja jaoteltu, jotta 
      muut ryhmän jäsenet tiesivät, missä vaiheessa ohjelma menee. Vaikka dokumentointi onnistui hyvin JSDoc -dokumentointityökalulla, olisin mielestäni voinut kirjoitella 
      ZenHubiin parempia sekä yksityiskohtaisempia taskeja - jossa tosin parannuin ajan myötä.
    </p>

    <p class='text-center mb-5'>
      Ryhmäprojektimme, <b>Pint.it</b>, opetti minulle ensimmäistä kertaa, kuinka natiiveja applikaatioita voidaan luoda JavaScriptilla ja kuinka puhelimelle ohjelmointi onnistuu
      erilaisten työkalujen ansiosta. Loppujen lopuksi olen ylpeä, mitä me ryhmänä saimme aikaan.
    </p>

  </div>



  <footer class='py-5 bg-dark'>
    <div class='container'>
      <p class='m-0 text-center text-white'>Samuli Rukkila | L4924 | 2019</p>
      <p class='m-0 text-center text-white'>Portfolio -sivu sovelluskehityksestä Pint.it -projektin kanssa</p>
    </div>
  </footer>

  <!-- Bootstrap core JavaScript -->
  <script src='vendor/jquery/jquery.min.js'></script>
  <script src='vendor/bootstrap/js/bootstrap.bundle.min.js'></script>
  <script src="./prism.js"></script>

</body>

</html>